# 1. git push
# i. Why do we use "git push"?

# a. Basic push

# Scenario: You created lesson_03.py, added it, and committed locally. Your branch is main.

# Question: What command pushes your changes to the remote repository?

# b. Pushing a new branch

# Scenario: You created a branch feature/loops to add exercises. You committed loops_exercises.py.

# Question: What command pushes this branch and sets it to track the remote?

# c. Force push

# Scenario: You amended a commit on main (changed the message) and need to update the remote.

# Question: What command will safely overwrite the remote branch?

# d. Pushing a tag

# Scenario: You tagged a release v1.0 after finishing the exercises.

# Question: How do you push this tag to the remote repository?

# 2. git fetch
# i. Why do we use "git fetch"?

# a. Safe update check

# Scenario:
# Youâ€™re on main. You want to see if the remote repository has new commits without changing your code.

# Question:
# What command do you run?

# b. Inspect fetched changes

# Scenario:
# You already ran git fetch. You want to see commits that exist on the remote but not locally.

# Question:
# What command shows those commits?

# c. Fetch from a specific remote

# Scenario:
# Your repo has two remotes: origin and upstream. You want to update your knowledge of upstream.

# Question:
# What command do you run?

# d. Fetch, then integrate explicitly

# Scenario:
# You want full control: first see changes, then integrate them into main.

# Question:
# What is the correct command sequence?